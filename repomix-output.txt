This file is a merged representation of the entire codebase of Fixed Point implementation for Stwo prover, combining all repository files into a single document.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
/
  Users/
    raphaeldoukhan/
      Desktop/
        numerair/
          src/
            eval.rs
            lib.rs

================================================================
Repository Files
================================================================

================
File: /Users/raphaeldoukhan/Desktop/numerair/src/eval.rs
================
use num_traits::One;
use stwo_prover::constraint_framework::EvalAtRow;

/// Evaluates the constraint for addition of fixed point numbers.
pub fn eval_add<E: EvalAtRow>(eval: &mut E, lhs: E::F, rhs: E::F, out: E::F) {
    eval.add_constraint(out - (lhs + rhs));
}

/// Evaluates the constraint for subtraction of fixed point numbers.
pub fn eval_sub<E: EvalAtRow>(eval: &mut E, lhs: E::F, rhs: E::F, out: E::F) {
    eval.add_constraint(out - (lhs - rhs));
}

/// Evaluates the constraints for fixed point multiplication
pub fn eval_mul<E: EvalAtRow>(
    eval: &mut E,
    lhs: E::F,   // First fixed point number
    rhs: E::F,   // Second fixed point number
    scale: E::F, // The scale factor (2^DEFAULT_SCALE)
    out: E::F,   // The output fixed point number
    rem: E::F,   // The remainder
    slack: E::F, // The slack variable
) {
    // First compute the raw product
    let prod = eval.add_intermediate(lhs * rhs);

    // Then constrain the division by scale factor using signed_div_rem
    // out = prod / scale (quotient)
    // rem = prod % scale (remainder)
    eval_signed_div_rem(eval, prod, scale, out, rem, slack);
}

/// Evaluates the constraints for the signed division and remainder.
pub fn eval_signed_div_rem<E: EvalAtRow>(
    eval: &mut E,
    value: E::F, // The value being divided
    div: E::F,   // The divisor
    q: E::F,     // The quotient output
    r: E::F,     // The remainder output
    s: E::F,     // The slack variable
) {
    // Core relationship: value = q * div + r
    eval.add_constraint(value - (q * div.clone() + r.clone()));

    // Constraint that the remainder is less than the divisor
    // r + s = div - 1
    eval.add_constraint(r + s - (div - E::F::one()));
}

#[cfg(test)]
mod tests {

    use num_traits::Zero;
    use rand::{rngs::StdRng, Rng, SeedableRng};
    use stwo_prover::{
        constraint_framework::{self, preprocessed_columns::gen_is_first, FrameworkEval},
        core::{
            backend::{Col, Column, CpuBackend},
            fields::{
                m31::{M31, P},
                qm31::SecureField,
            },
            pcs::TreeVec,
            poly::{
                circle::{CanonicCoset, CircleEvaluation},
                BitReversedOrder,
            },
        },
    };

    use crate::{FixedM31, SCALE_FACTOR};

    use super::*;

    struct TestEval {
        log_size: u32,
        op: Op,
        total_sum: SecureField,
    }

    #[derive(Clone, Copy)]
    enum Op {
        Add,
        Sub,
        Mul,
        SignedDivRem,
    }

    impl FrameworkEval for TestEval {
        fn log_size(&self) -> u32 {
            self.log_size
        }

        fn max_constraint_log_degree_bound(&self) -> u32 {
            self.log_size + 1
        }

        fn evaluate<E: EvalAtRow>(&self, mut eval: E) -> E {
            match self.op {
                Op::Add => {
                    let lhs = eval.next_trace_mask();
                    let rhs = eval.next_trace_mask();
                    let out = eval.next_trace_mask();
                    eval_add(&mut eval, lhs, rhs, out)
                }
                Op::Sub => {
                    let lhs = eval.next_trace_mask();
                    let rhs = eval.next_trace_mask();
                    let out = eval.next_trace_mask();
                    eval_sub(&mut eval, lhs, rhs, out)
                }
                Op::Mul => {
                    let lhs = eval.next_trace_mask();
                    let rhs = eval.next_trace_mask();
                    let out = eval.next_trace_mask();
                    let rem = eval.next_trace_mask();
                    let slack = eval.next_trace_mask();
                    eval_mul(&mut eval, lhs, rhs, SCALE_FACTOR.into(), out, rem, slack)
                }
                Op::SignedDivRem => {
                    let value = eval.next_trace_mask();
                    let div = eval.next_trace_mask();
                    let q = eval.next_trace_mask();
                    let r = eval.next_trace_mask();
                    let s = eval.next_trace_mask();
                    eval_signed_div_rem(&mut eval, value, div, q, r, s)
                }
                _ => unimplemented!(),
            }
            eval
        }
    }

    fn columns_to_evaluations(
        cols: Vec<Vec<M31>>,
        domain: CanonicCoset,
    ) -> Vec<CircleEvaluation<CpuBackend, M31, BitReversedOrder>> {
        cols.into_iter()
            .map(|col| {
                let mut trace_col = Col::<CpuBackend, M31>::zeros(1 << domain.log_size());
                for (i, val) in col.iter().enumerate() {
                    trace_col.set(i, *val);
                }
                CircleEvaluation::new(domain.circle_domain(), trace_col)
            })
            .collect()
    }

    fn test_op(op: Op, inputs: Vec<FixedM31>, expected_outputs: Vec<FixedM31>) {
        const LOG_SIZE: u32 = 4;
        let domain = CanonicCoset::new(LOG_SIZE);
        let size = 1 << LOG_SIZE;

        // Convert inputs and outputs to M31
        let inputs: Vec<M31> = inputs.iter().map(|x| x.0).collect();
        let outputs: Vec<M31> = expected_outputs.iter().map(|x| x.0).collect();

        // Generate trace
        let mut trace_cols = vec![Vec::new(); inputs.len() + outputs.len()];
        for _ in 0..size {
            for (i, input) in inputs.iter().enumerate() {
                trace_cols[i].push(*input);
            }
            for (i, output) in outputs.iter().enumerate() {
                trace_cols[inputs.len() + i].push(*output);
            }
        }

        let trace_evals = columns_to_evaluations(trace_cols.clone(), domain);
        let trace = TreeVec::new(vec![vec![gen_is_first(LOG_SIZE)], trace_evals, Vec::new()]);

        let trace_polys = trace.map_cols(|c| c.interpolate());

        let component = TestEval {
            log_size: LOG_SIZE,
            total_sum: SecureField::zero(),
            op,
        };

        // Test valid trace
        constraint_framework::assert_constraints(
            &trace_polys,
            domain,
            |eval| {
                component.evaluate(eval);
            },
            (SecureField::zero(), None),
        );

        // Test invalid trace - modify the output column
        let mut invalid_trace_cols = trace_cols;
        if let Some(last_col) = invalid_trace_cols.last_mut() {
            for val in last_col.iter_mut() {
                val.0 = (val.0 + 1) % P;
            }
        }

        let invalid_trace_evals = columns_to_evaluations(invalid_trace_cols, domain);
        let invalid_trace = TreeVec::new(vec![
            vec![gen_is_first(LOG_SIZE)],
            invalid_trace_evals,
            Vec::new(),
        ]);

        let invalid_trace_polys = invalid_trace.map_cols(|c| c.interpolate());

        // This should panic for invalid trace
        let result = std::panic::catch_unwind(|| {
            constraint_framework::assert_constraints(
                &invalid_trace_polys,
                domain,
                |eval| {
                    component.evaluate(eval);
                },
                (SecureField::zero(), None),
            );
        });
        assert!(result.is_err());
    }

    #[test]
    fn test_random_add() {
        let mut rng = StdRng::seed_from_u64(42);
        for _ in 0..100 {
            let a = FixedM31::new((rng.gen::<f64>() - 0.5) * 200.0);
            let b = FixedM31::new((rng.gen::<f64>() - 0.5) * 200.0);

            test_op(Op::Add, vec![a, b], vec![a + b]);
        }
    }

    #[test]
    fn test_random_sub() {
        let mut rng = StdRng::seed_from_u64(42);
        for _ in 0..100 {
            let a = FixedM31::new((rng.gen::<f64>() - 0.5) * 200.0);
            let b = FixedM31::new((rng.gen::<f64>() - 0.5) * 200.0);
            test_op(Op::Sub, vec![a, b], vec![a - b]);
        }
    }

    #[test]
    fn test_signed_div_rem() {
        let mut rng = StdRng::seed_from_u64(42);

        // Test different divisors
        let divisors = vec![M31(7), M31(13), M31(23)];

        for div in divisors {
            for _ in 0..10 {
                // Generate random value between -1000 and 1000
                let val = (rng.gen::<f64>() - 0.5) * 2000.0;
                let fixed_val = FixedM31::new(val);

                // Compute expected results using the actual implementation
                let (expected_q, expected_r) = fixed_val.signed_div_rem(div);
                // Calculate slack: r + s = div - 1
                let expected_s = FixedM31(div - M31::one() - expected_r.0);

                // Test the constraint system
                test_op(
                    Op::SignedDivRem,
                    vec![fixed_val, FixedM31(div)],
                    vec![expected_q, expected_r, expected_s],
                );
            }
        }

        // Test special cases
        let test_cases = vec![
            // (value, divisor)
            (100, 7),  // Positive number normal case
            (-100, 7), // Negative number normal case
            (21, 7),   // Zero remainder case
            (-21, 7),  // Negative with zero remainder
            (1, 1),    // Edge case with divisor 1
            (-1, 1),   // Edge case with divisor 1 negative
        ];

        for (value, divisor) in test_cases {
            let fixed_val = FixedM31::new(value as f64);
            let div = M31(divisor);
            let (expected_q, expected_r) = fixed_val.signed_div_rem(div);
            let expected_s = FixedM31(div - M31::one() - expected_r.0);

            test_op(
                Op::SignedDivRem,
                vec![fixed_val, FixedM31(div)],
                vec![expected_q, expected_r, expected_s],
            );
        }
    }

    #[test]
    fn test_mul() {
        let mut rng = StdRng::seed_from_u64(42);

        // Test regular multiplication cases
        for _ in 0..100 {
            let a = (rng.gen::<f64>() - 0.5) * 10.0; // Random between -5 and 5
            let b = (rng.gen::<f64>() - 0.5) * 10.0;

            let fixed_a = FixedM31::new(a);
            let fixed_b = FixedM31::new(b);
            let expected = fixed_a * fixed_b;

            // Calculate remainder and slack
            let prod = fixed_a.0 * fixed_b.0;
            let (_, rem) = FixedM31(prod).signed_div_rem(SCALE_FACTOR);
            let slack = FixedM31(SCALE_FACTOR - M31::one() - rem.0);

            test_op(Op::Mul, vec![fixed_a, fixed_b], vec![expected, rem, slack]);
        }

        // Test special cases
        let special_cases = vec![
            (0.0, 0.0),    // Zero multiplication
            (1.0, 1.0),    // Unit multiplication
            (-1.0, 1.0),   // Sign handling
            (1.0, -1.0),   // Sign handling other direction
            (-1.0, -1.0),  // Negative times negative
            (0.5, 0.5),    // Fractional multiplication
            (-0.5, 0.5),   // Fractional with sign
            (3.14, 2.0),   // Pi times 2
            (-3.14, -2.0), // Negative Pi times negative
        ];

        for (a, b) in special_cases {
            let fixed_a = FixedM31::new(a);
            let fixed_b = FixedM31::new(b);
            let expected = fixed_a * fixed_b;

            // Calculate remainder and slack
            let prod = fixed_a.0 * fixed_b.0;
            let (_, rem) = FixedM31(prod).signed_div_rem(SCALE_FACTOR);
            let slack = FixedM31(SCALE_FACTOR - M31::one() - rem.0);

            test_op(Op::Mul, vec![fixed_a, fixed_b], vec![expected, rem, slack]);
        }
    }
}

================
File: /Users/raphaeldoukhan/Desktop/numerair/src/lib.rs
================
use std::ops::{Add, Mul, Sub};
use stwo_prover::core::fields::m31::{M31, P};

pub mod eval;

/// Fixed point number implementation over M31 field
/// The value is stored as 2^scale * x
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct FixedM31(pub M31);

pub const DEFAULT_SCALE: u32 = 12;
// Pre-compute scale factor as M31 field element
pub const SCALE_FACTOR: M31 = M31::from_u32_unchecked(1 << DEFAULT_SCALE);

impl FixedM31 {
    pub fn new(x: f64) -> Self {
        let scaled = (x * (1u64 << DEFAULT_SCALE) as f64).round() as i64;
        let val = scaled.rem_euclid(P as i64) as u32;
        FixedM31(M31(val))
    }

    pub fn to_f64(&self) -> f64 {
        let val = if self.0 .0 > P / 2 {
            -(((P - self.0 .0) as i64) as f64)
        } else {
            self.0 .0 as f64
        };
        val / (1u64 << DEFAULT_SCALE) as f64
    }

    pub fn abs(&self) -> Self {
        let is_neg = self.is_negative();
        let pos = *self;
        let neg = FixedM31(-self.0);
        Self(if is_neg { neg.0 } else { pos.0 })
    }

    pub fn is_negative(&self) -> bool {
        (self.0 .0 & !(P / 2)) != 0
    }

    pub fn signed_div_rem(&self, div: M31) -> (FixedM31, FixedM31) {
        let value = self.0 .0;
        let divisor = div.0;

        let is_negative = value > P / 2;
        let abs_value = if is_negative { P - value } else { value };

        let q = abs_value / divisor;
        let r = abs_value % divisor;

        if r == 0 {
            (
                FixedM31(M31(if is_negative { P - q } else { q })),
                FixedM31(M31(0)),
            )
        } else if is_negative {
            (FixedM31(M31(P - (q + 1))), FixedM31(M31(divisor - r)))
        } else {
            (FixedM31(M31(q)), FixedM31(M31(r)))
        }
    }
}

impl Add for FixedM31 {
    type Output = Self;

    fn add(self, rhs: Self) -> Self {
        // Field addition preserves the scale factor
        FixedM31(self.0 + rhs.0)
    }
}

impl Sub for FixedM31 {
    type Output = Self;

    fn sub(self, rhs: Self) -> Self {
        // Field subtraction preserves the scale factor
        FixedM31(self.0 - rhs.0)
    }
}

impl Mul for FixedM31 {
    type Output = Self;

    fn mul(self, rhs: Self) -> Self {
        let prod = self.0 * rhs.0;

        let (res, _) = FixedM31(prod).signed_div_rem(SCALE_FACTOR);

        res
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use rand::rngs::StdRng;
    use rand::{Rng, SeedableRng};

    const EPSILON: f64 = 1e-2;

    fn assert_near(a: f64, b: f64) {
        assert!((a - b).abs() < EPSILON, "Expected {} to be near {}", a, b);
    }

    #[test]
    fn test_basic_ops() {
        let a = FixedM31::new(3.5);
        let b = FixedM31::new(2.0);

        assert_near(a.to_f64(), 3.5);
        assert_near(b.to_f64(), 2.0);
        assert_near((a + b).to_f64(), 5.5);
        assert_near((a - b).to_f64(), 1.5);
    }

    #[test]
    fn test_negative() {
        let a = FixedM31::new(-3.5);
        let b = FixedM31::new(2.0);

        assert_near(a.to_f64(), -3.5);
        assert_near((a + b).to_f64(), -1.5);
        assert_near((a - b).to_f64(), -5.5);
    }

    #[test]
    fn test_mul() {
        let mut rng = StdRng::seed_from_u64(42);

        for _ in 0..1000 {
            // Generate random values between -100 and 100
            let a = (rng.gen::<f64>() - 0.5) * 10.0;
            let b = (rng.gen::<f64>() - 0.5) * 10.0;

            let fa = FixedM31::new(a);
            let fb = FixedM31::new(b);

            let result = (fa * fb).to_f64();
            let expected = a * b;

            println!(
                "a: {}, b: {}, result: {}, expected: {}",
                a, b, result, expected
            );
            assert_near(result, expected);
        }
    }

    #[test]
    fn test_signed_div_rem() {
        // Test positive numbers
        let x = FixedM31(M31(100));
        let div = M31(7);
        let (q, r) = x.signed_div_rem(div);
        assert_eq!(q.0 .0, 14); // 100 ÷ 7 = 14
        assert_eq!(r.0 .0, 2); // 100 = 14 * 7 + 2

        // Test negative numbers
        let x = FixedM31(M31(P - 100)); // Represents -100
        let (q, r) = x.signed_div_rem(div);
        assert_eq!(q.0 .0, P - 15); // -100 ÷ 7 = -15 (represented as P - 15)
        assert_eq!(r.0 .0, 5); // -100 = -15 * 7 + 5

        // Test zero remainder
        let x = FixedM31(M31(21));
        let (q, r) = x.signed_div_rem(div);
        assert_eq!(q.0 .0, 3);
        assert_eq!(r.0 .0, 0);

        // Test negative number with zero remainder
        let x = FixedM31(M31(P - 21)); // Represents -21
        let (q, r) = x.signed_div_rem(div);
        assert_eq!(q.0 .0, P - 3); // Represents -3
        assert_eq!(r.0 .0, 0);
    }
}
